{"componentChunkName":"component---src-templates-handbook-tsx","path":"/docs/handbook/project-references.html","webpackCompilationHash":"9ba7cceb403e6d704a1e","result":{"data":{"markdownRemark":{"id":"0ca51fa2-80ae-5e27-bc48-8b71386c5032","excerpt":"{% raw %}Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces. By doing this, you can…","html":"<p>{% raw %}Project references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.</p>\n<p>By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.</p>\n<p>We’re also introducing a new mode for <code class=\"language-text\">tsc</code>, the <code class=\"language-text\">--build</code> flag, that works hand in hand with project references to enable faster TypeScript builds.</p>\n<h1>An Example Project</h1>\n<p>Let’s look at a fairly normal program and see how project references can help us better organize it.\nImagine you have a project with two modules, <code class=\"language-text\">converter</code> and <code class=\"language-text\">units</code>, and a corresponding test file for each:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">/src/converter.ts\n/src/units.ts\n/test/converter-tests.ts\n/test/units-tests.ts\n/tsconfig.json</code></pre></div>\n<p>The test files import the implementation files and do some testing:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// converter-tests.ts</span>\n<span class=\"token keyword\">import</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">as</span> converter <span class=\"token keyword\">from</span> <span class=\"token string\">\"../converter\"</span><span class=\"token punctuation\">;</span>\n\nassert<span class=\"token punctuation\">.</span><span class=\"token function\">areEqual</span><span class=\"token punctuation\">(</span>converter<span class=\"token punctuation\">.</span><span class=\"token function\">celsiusToFahrenheit</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">32</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Previously, this structure was rather awkward to work with if you used a single tsconfig file:</p>\n<ul>\n<li>It was possible for the implementation files to import the test files</li>\n<li>It wasn’t possible to build <code class=\"language-text\">test</code> and <code class=\"language-text\">src</code> at the same time without having <code class=\"language-text\">src</code> appear in the output folder name, which you probably don’t want</li>\n<li>Changing just the <em>internals</em> in the implementation files required <em>typechecking</em> the tests again, even though this wouldn’t ever cause new errors</li>\n<li>Changing just the tests required typechecking the implementation again, even if nothing changed</li>\n</ul>\n<p>You could use multiple tsconfig files to solve <em>some</em> of those problems, but new ones would appear:</p>\n<ul>\n<li>There’s no built-in up-to-date checking, so you end up always running <code class=\"language-text\">tsc</code> twice</li>\n<li>Invoking <code class=\"language-text\">tsc</code> twice incurs more startup time overhead</li>\n<li><code class=\"language-text\">tsc -w</code> can’t run on multiple config files at once</li>\n</ul>\n<p>Project references can solve all of these problems and more.</p>\n<h1>What is a Project Reference?</h1>\n<p><code class=\"language-text\">tsconfig.json</code> files have a new top-level property, <code class=\"language-text\">references</code>. It’s an array of objects that specifies projects to reference:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"compilerOptions\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// The usual</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token string\">\"references\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{</span> <span class=\"token string\">\"path\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"../src\"</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The <code class=\"language-text\">path</code> property of each reference can point to a directory containing a <code class=\"language-text\">tsconfig.json</code> file, or to the config file itself (which may have any name).</p>\n<p>When you reference a project, new things happen:</p>\n<ul>\n<li>Importing modules from a referenced project will instead load its <em>output</em> declaration file (<code class=\"language-text\">.d.ts</code>)</li>\n<li>If the referenced project produces an <code class=\"language-text\">outFile</code>, the output file <code class=\"language-text\">.d.ts</code> file’s declarations will be visible in this project</li>\n<li>Build mode (see below) will automatically build the referenced project if needed</li>\n</ul>\n<p>By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.</p>\n<h1><code class=\"language-text\">composite</code></h1>\n<p>Referenced projects must have the new <code class=\"language-text\">composite</code> setting enabled.\nThis setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project.\nEnabling the <code class=\"language-text\">composite</code> flag changes a few things:</p>\n<ul>\n<li>The <code class=\"language-text\">rootDir</code> setting, if not explicitly set, defaults to the directory containing the <code class=\"language-text\">tsconfig</code> file</li>\n<li>All implementation files must be matched by an <code class=\"language-text\">include</code> pattern or listed in the <code class=\"language-text\">files</code> array. If this constraint is violated, <code class=\"language-text\">tsc</code> will inform you which files weren’t specified</li>\n<li><code class=\"language-text\">declaration</code> must be turned on</li>\n</ul>\n<h1><code class=\"language-text\">declarationMap</code>s</h1>\n<p>We’ve also added support for <a href=\"https://github.com/Microsoft/TypeScript/issues/14479\">declaration source maps</a>.\nIf you enable <code class=\"language-text\">--declarationMap</code>, you’ll be able to use editor features like “Go to Definition” and Rename to transparently navigate and edit code across project boundaries in supported editors.</p>\n<h1><code class=\"language-text\">prepend</code> with <code class=\"language-text\">outFile</code></h1>\n<p>You can also enable prepending the output of a dependency using the <code class=\"language-text\">prepend</code> option in a reference:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">   <span class=\"token string\">\"references\"</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>\n       <span class=\"token punctuation\">{</span> <span class=\"token string\">\"path\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"../utils\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"prepend\"</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">]</span></code></pre></div>\n<p>Prepending a project will include the project’s output above the output of the current project.\nThis works for both <code class=\"language-text\">.js</code> files and <code class=\"language-text\">.d.ts</code> files, and source map files will also be emitted correctly.</p>\n<p><code class=\"language-text\">tsc</code> will only ever use existing files on disk to do this process, so it’s possible to create a project where a correct output file can’t be generated because some project’s output would be present more than once in the resulting file.\nFor example:</p>\n<div class=\"gatsby-highlight\" data-language=\"txt\"><pre class=\"language-txt\"><code class=\"language-txt\">   A\n  ^ ^\n /   \\\nB     C\n ^   ^\n  \\ /\n   D</code></pre></div>\n<p>It’s important in this situation to not prepend at each reference, because you’ll end up with two copies of <code class=\"language-text\">A</code> in the output of <code class=\"language-text\">D</code> - this can lead to unexpected results.</p>\n<h1>Caveats for Project References</h1>\n<p>Project references have a few trade-offs you should be aware of.</p>\n<p>Because dependent projects make use of <code class=\"language-text\">.d.ts</code> files that are built from their dependencies, you’ll either have to check in certain build outputs <em>or</em> build a project after cloning it before you can navigate the project in an editor without seeing spurious errors.\nWe’re working on a behind-the-scenes .d.ts generation process that should be able to mitigate this, but for now we recommend informing developers that they should build after cloning.</p>\n<p>Additionally, to preserve compatibility with existing build workflows, <code class=\"language-text\">tsc</code> will <em>not</em> automatically build dependencies unless invoked with the <code class=\"language-text\">--build</code> switch.\nLet’s learn more about <code class=\"language-text\">--build</code>.</p>\n<h1>Build Mode for TypeScript</h1>\n<p>A long-awaited feature is smart incremental builds for TypeScript projects.\nIn 3.0 you can use the <code class=\"language-text\">--build</code> flag with <code class=\"language-text\">tsc</code>.\nThis is effectively a new entry point for <code class=\"language-text\">tsc</code> that behaves more like a build orchestrator than a simple compiler.</p>\n<p>Running <code class=\"language-text\">tsc --build</code> (<code class=\"language-text\">tsc -b</code> for short) will do the following:</p>\n<ul>\n<li>Find all referenced projects</li>\n<li>Detect if they are up-to-date</li>\n<li>Build out-of-date projects in the correct order</li>\n</ul>\n<p>You can provide <code class=\"language-text\">tsc -b</code> with multiple config file paths (e.g. <code class=\"language-text\">tsc -b src test</code>).\nJust like <code class=\"language-text\">tsc -p</code>, specifying the config file name itself is unnecessary if it’s named <code class=\"language-text\">tsconfig.json</code>.</p>\n<h2><code class=\"language-text\">tsc -b</code> Commandline</h2>\n<p>You can specify any number of config files:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"> <span class=\"token operator\">></span> tsc -b                            <span class=\"token comment\"># Use the tsconfig.json in the current directory</span>\n <span class=\"token operator\">></span> tsc -b src                        <span class=\"token comment\"># Use src/tsconfig.json</span>\n <span class=\"token operator\">></span> tsc -b foo/prd.tsconfig.json bar  <span class=\"token comment\"># Use foo/prd.tsconfig.json and bar/tsconfig.json</span></code></pre></div>\n<p>Don’t worry about ordering the files you pass on the commandline - <code class=\"language-text\">tsc</code> will re-order them if needed so that dependencies are always built first.</p>\n<p>There are also some flags specific to <code class=\"language-text\">tsc -b</code>:</p>\n<ul>\n<li><code class=\"language-text\">--verbose</code>: Prints out verbose logging to explain what’s going on (may be combined with any other flag)</li>\n<li><code class=\"language-text\">--dry</code>: Shows what would be done but doesn’t actually build anything</li>\n<li><code class=\"language-text\">--clean</code>: Deletes the outputs of the specified projects (may be combined with <code class=\"language-text\">--dry</code>)</li>\n<li><code class=\"language-text\">--force</code>: Act as if all projects are out of date</li>\n<li><code class=\"language-text\">--watch</code>: Watch mode (may not be combined with any flag except <code class=\"language-text\">--verbose</code>)</li>\n</ul>\n<h1>Caveats</h1>\n<p>Normally, <code class=\"language-text\">tsc</code> will produce outputs (<code class=\"language-text\">.js</code> and <code class=\"language-text\">.d.ts</code>) in the presence of syntax or type errors, unless <code class=\"language-text\">noEmitOnError</code> is on.\nDoing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you’d only see it <em>once</em> because a subsequent build would skip building the now up-to-date project.\nFor this reason, <code class=\"language-text\">tsc -b</code> effectively acts as if <code class=\"language-text\">noEmitOnError</code> is enabled for all projects.</p>\n<p>If you check in any build outputs (<code class=\"language-text\">.js</code>, <code class=\"language-text\">.d.ts</code>, <code class=\"language-text\">.d.ts.map</code>, etc.), you may need to run a <code class=\"language-text\">--force</code> build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.</p>\n<h1>MSBuild</h1>\n<p>If you have an msbuild project, you can enable build mode by adding</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\">    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TypeScriptBuildMode</span><span class=\"token punctuation\">></span></span>true<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>TypeScriptBuildMode</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>to your proj file. This will enable automatic incremental build as well as cleaning.</p>\n<p>Note that as with <code class=\"language-text\">tsconfig.json</code> / <code class=\"language-text\">-p</code>, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</p>\n<p>Some teams have set up msbuild-based workflows wherein tsconfig files have the same <em>implicit</em> graph ordering as the managed projects they are paired with.\nIf your solution is like this, you can continue to use <code class=\"language-text\">msbuild</code> with <code class=\"language-text\">tsc -p</code> along with project references; these are fully interoperable.</p>\n<h1>Guidance</h1>\n<h2>Overall Structure</h2>\n<p>With more <code class=\"language-text\">tsconfig.json</code> files, you’ll usually want to use <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">Configuration file inheritance</a> to centralize your common compiler options.\nThis way you can change a setting in one file rather than having to edit multiple files.</p>\n<p>Another good practice is to have a “solution” <code class=\"language-text\">tsconfig.json</code> file that simply has <code class=\"language-text\">references</code> to all of your leaf-node projects.\nThis presents a simple entry point; e.g. in the TypeScript repo we simply run <code class=\"language-text\">tsc -b src</code> to build all endpoints because we list all the subprojects in <code class=\"language-text\">src/tsconfig.json</code>\nNote that starting with 3.0, it is no longer an error to have an empty <code class=\"language-text\">files</code> array if you have at least one <code class=\"language-text\">reference</code> in a <code class=\"language-text\">tsconfig.json</code> file.</p>\n<p>You can see these patterns in the TypeScript repo - see <code class=\"language-text\">src/tsconfig_base.json</code>, <code class=\"language-text\">src/tsconfig.json</code>, and <code class=\"language-text\">src/tsc/tsconfig.json</code> as key examples.</p>\n<h2>Structuring for relative modules</h2>\n<p>In general, not much is needed to transition a repo using relative modules.\nSimply place a <code class=\"language-text\">tsconfig.json</code> file in each subdirectory of a given parent folder, and add <code class=\"language-text\">reference</code>s to these config files to match the intended layering of the program.\nYou will need to either set the <code class=\"language-text\">outDir</code> to an explicit subfolder of the output folder, or set the <code class=\"language-text\">rootDir</code> to the common root of all project folders.</p>\n<h2>Structuring for outFiles</h2>\n<p>Layout for compilations using <code class=\"language-text\">outFile</code> is more flexible because relative paths don’t matter as much.\nOne thing to keep in mind is that you’ll generally want to not use <code class=\"language-text\">prepend</code> until the “last” project - this will improve build times and reduce the amount of I/O needed in any given build.\nThe TypeScript repo itself is a good reference here - we have some “library” projects and some “endpoint” projects; “endpoint” projects are kept as small as possible and pull in only the libraries they need.</p>\n<!--\n## Structuring for monorepos\n\nTODO: Experiment more and figure this out. Rush and Lerna seem to have different models that imply different things on our end\n-->\n<p>{% endraw %}</p>","frontmatter":{"permalink":"/docs/handbook/project-references.html"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/docs/handbook/project-references.html","isOldHandbook":true}}}