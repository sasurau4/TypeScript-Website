{"componentChunkName":"component---src-templates-handbook-tsx","path":"/docs/handbook/release-notes/typescript-2-5.html","webpackCompilationHash":"9ba7cceb403e6d704a1e","result":{"data":{"markdownRemark":{"id":"5dc2f01b-7adf-50e0-86b5-fd8001c0e063","excerpt":"{% raw %}## Optional  clause variables Thanks to work done by @tinganho, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the…","html":"<p>{% raw %}## Optional <code class=\"language-text\">catch</code> clause variables</p>\n<p>Thanks to work done by <a href=\"https://github.com/tinganho\">@tinganho</a>, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in <code class=\"language-text\">catch</code> clauses.\nFor example, when using <code class=\"language-text\">JSON.parse</code> you may need to wrap calls to the function with a <code class=\"language-text\">try</code>/<code class=\"language-text\">catch</code>, but you may not end up using the <code class=\"language-text\">SyntaxError</code> that gets thrown when input is erroneous.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> input <span class=\"token operator\">=</span> <span class=\"token string\">\"...\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">catch</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ^ Notice that our `catch` clause doesn't declare a variable.</span>\n    <span class=\"token builtin\">console</span><span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid JSON given\\n\\n\"</span> <span class=\"token operator\">+</span> input<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Type assertion/cast syntax in <code class=\"language-text\">checkJs</code>/<code class=\"language-text\">@ts-check</code> mode</h2>\n<p>TypeScript 2.5 introduces the ability to <a href=\"https://github.com/Microsoft/TypeScript/issues/5158\">assert the type of expressions when using plain JavaScript in your projects</a>.\nThe syntax is an <code class=\"language-text\">/** @type {...} */</code> annotation comment followed by a parenthesized expression whose type needs to be re-evaluated.\nFor example:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">var</span> x <span class=\"token operator\">=</span> <span class=\"token comment\">/** @type {SomeType} */</span> <span class=\"token punctuation\">(</span>AnyParenthesizedExpression<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2>Deduplicated and redirected packages</h2>\n<p>When importing using the <code class=\"language-text\">Node</code> module resolution strategy in TypeScript 2.5, the compiler will now check whether files originate from “identical” packages.\nIf a file originates from a package with a <code class=\"language-text\">package.json</code> containing the same <code class=\"language-text\">name</code> and <code class=\"language-text\">version</code> fields as a previously encountered package, then TypeScript will redirect itself to the top-most package.\nThis helps resolve problems where two packages might contain identical declarations of classes, but which contain <code class=\"language-text\">private</code> members that cause them to be structurally incompatible.</p>\n<p>As a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading <code class=\"language-text\">.d.ts</code> files from duplicate packages.</p>\n<h2>The <code class=\"language-text\">--preserveSymlinks</code> compiler flag</h2>\n<p>TypeScript 2.5 brings the <code class=\"language-text\">preserveSymlinks</code> flag, which parallels the behavior of <a href=\"https://nodejs.org/api/cli.html#cli_preserve_symlinks\">the <code class=\"language-text\">--preserve-symlinks</code> flag in Node.js</a>.\nThis flag also exhibits the opposite behavior to Webpack’s <code class=\"language-text\">resolve.symlinks</code> option (i.e. setting TypeScript’s <code class=\"language-text\">preserveSymlinks</code> to <code class=\"language-text\">true</code> parallels setting Webpack’s <code class=\"language-text\">resolve.symlinks</code> to <code class=\"language-text\">false</code>, and vice-versa).</p>\n<p>In this mode, references to modules and packages (e.g. <code class=\"language-text\">import</code>s and <code class=\"language-text\">/// &lt;reference type=&quot;...&quot; /&gt;</code> directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to.\nFor a more concrete example, we’ll defer to <a href=\"https://nodejs.org/api/cli.html#cli_preserve_symlinks\">the documentation on the Node.js website</a>.</p>\n<p>{% endraw %}</p>","frontmatter":{"permalink":"/docs/handbook/release-notes/typescript-2-5.html"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/docs/handbook/release-notes/typescript-2-5.html","isOldHandbook":true}}}