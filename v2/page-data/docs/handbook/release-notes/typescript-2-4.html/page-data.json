{"componentChunkName":"component---src-templates-handbook-tsx","path":"/docs/handbook/release-notes/typescript-2-4.html","webpackCompilationHash":"9ba7cceb403e6d704a1e","result":{"data":{"markdownRemark":{"id":"3464162a-497b-5db4-896b-5f460c7d78d5","excerpt":"{% raw %}## Dynamic Import Expressions Dynamic  expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any…","html":"<p>{% raw %}## Dynamic Import Expressions</p>\n<p>Dynamic <code class=\"language-text\">import</code> expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</p>\n<p>This means that you can conditionally and lazily import other modules and libraries.\nFor example, here’s an <code class=\"language-text\">async</code> function that only imports a utility library when it’s needed:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getZipFile</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">name<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> files<span class=\"token punctuation\">:</span> File<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>File<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> zipUtil <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">import</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./utils/create-zip-file'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">const</span> zipContents <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> zipUtil<span class=\"token punctuation\">.</span><span class=\"token function\">getContentAsBlob</span><span class=\"token punctuation\">(</span>files<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">File</span><span class=\"token punctuation\">(</span>zipContents<span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Many bundlers have support for automatically splitting output bundles based on these <code class=\"language-text\">import</code> expressions, so consider using this new feature with the <code class=\"language-text\">esnext</code> module target.</p>\n<h2>String Enums</h2>\n<p>TypeScript 2.4 now allows enum members to contain string initializers.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">enum</span> Colors <span class=\"token punctuation\">{</span>\n    Red <span class=\"token operator\">=</span> <span class=\"token string\">\"RED\"</span><span class=\"token punctuation\">,</span>\n    Green <span class=\"token operator\">=</span> <span class=\"token string\">\"GREEN\"</span><span class=\"token punctuation\">,</span>\n    Blue <span class=\"token operator\">=</span> <span class=\"token string\">\"BLUE\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The caveat is that string-initialized enums can’t be reverse-mapped to get the original enum member name.\nIn other words, you can’t write <code class=\"language-text\">Colors[&quot;RED&quot;]</code> to get the string <code class=\"language-text\">&quot;Red&quot;</code>.</p>\n<h2>Improved inference for generics</h2>\n<p>TypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.</p>\n<h3>Return types as inference targets</h3>\n<p>For one, TypeScript can now make inferences for the return type of a call.\nThis can improve your experience and catch errors.\nSomething that now works:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> arrayMap<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">f</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token parameter\">a</span> <span class=\"token operator\">=></span> a<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">lengths</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">arrayMap</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">s</span> <span class=\"token operator\">=></span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>As an example of new errors you might spot as a result:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> x<span class=\"token punctuation\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//      ~~ Error!</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Type parameter inference from contextual types</h3>\n<p>Prior to TypeScript 2.4, in the following example</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> f<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function-variable function\">T</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">y</span> <span class=\"token operator\">=></span> y<span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">y</code> would have the type <code class=\"language-text\">any</code>.\nThis meant the program would type-check, but you could technically do anything with <code class=\"language-text\">y</code>, such as the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> f<span class=\"token punctuation\">:</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function-variable function\">T</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">y</span> <span class=\"token operator\">=></span> <span class=\"token function\">y</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> y<span class=\"token punctuation\">.</span>foo<span class=\"token punctuation\">.</span>bar<span class=\"token punctuation\">;</span></code></pre></div>\n<p>That last example isn’t actually type-safe.</p>\n<p>In TypeScript 2.4, the function on the right side implicitly <em>gains</em> type parameters, and <code class=\"language-text\">y</code> is inferred to have the type of that type-parameter.</p>\n<p>If you use <code class=\"language-text\">y</code> in a way that the type parameter’s constraint doesn’t support, you’ll correctly get an error.\nIn this case, the constraint of <code class=\"language-text\">T</code> was (implicitly) <code class=\"language-text\">{}</code>, so the last example will appropriately fail.</p>\n<h3>Stricter checking for generic functions</h3>\n<p>TypeScript now tries to unify type parameters when comparing two single-signature types.\nAs a result, you’ll get stricter checks when relating two generic signatures, and may catch some bugs.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token constant\">A</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token constant\">U</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">U</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token constant\">B</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token constant\">S</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">S</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">:</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token constant\">B</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Error</span>\n    b <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span>  <span class=\"token comment\">// Ok</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Strict contravariance for callback parameters</h2>\n<p>TypeScript has always compared parameters in a bivariant way.\nThere are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with <code class=\"language-text\">Promise</code>s and <code class=\"language-text\">Observable</code>s.</p>\n<p>TypeScript 2.4 introduces tightens this up when relating two callback types. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Mappable</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    map<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token function-variable function\">f</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">x<span class=\"token punctuation\">:</span> <span class=\"token constant\">T</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">U</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> Mappable<span class=\"token operator\">&lt;</span><span class=\"token constant\">U</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> a<span class=\"token punctuation\">:</span> Mappable<span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">declare</span> <span class=\"token keyword\">let</span> b<span class=\"token punctuation\">:</span> Mappable<span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\na <span class=\"token operator\">=</span> b<span class=\"token punctuation\">;</span>\nb <span class=\"token operator\">=</span> a<span class=\"token punctuation\">;</span></code></pre></div>\n<p>Prior to TypeScript 2.4, this example would succeed.\nWhen relating the types of <code class=\"language-text\">map</code>, TypeScript would bidirectionally relate their parameters (i.e. the type of <code class=\"language-text\">f</code>).\nWhen relating each <code class=\"language-text\">f</code>, TypeScript would also bidirectionally relate the type of <em>those</em> parameters.</p>\n<p>When relating the type of <code class=\"language-text\">map</code> in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.</p>\n<p>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</p>\n<h2>Weak Type Detection</h2>\n<p>TypeScript 2.4 introduces the concept of “weak types”.\nAny type that contains nothing but a set of all-optional properties is considered to be <em>weak</em>.\nFor example, this <code class=\"language-text\">Options</code> type is a weak type:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">Options</span> <span class=\"token punctuation\">{</span>\n    data<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span>\n    timeout<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span>\n    maxRetries<span class=\"token operator\">?</span><span class=\"token punctuation\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In TypeScript 2.4, it’s now an error to assign anything to a weak type when there’s no overlap in properties.\nFor example:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">sendMessage</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">options<span class=\"token punctuation\">:</span> Options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> opts <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    payload<span class=\"token punctuation\">:</span> <span class=\"token string\">\"hello world!\"</span><span class=\"token punctuation\">,</span>\n    retryOnFail<span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Error!</span>\n<span class=\"token function\">sendMessage</span><span class=\"token punctuation\">(</span>opts<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// No overlap between the type of 'opts' and 'Options' itself.</span>\n<span class=\"token comment\">// Maybe we meant to use 'data'/'maxRetries' instead of 'payload'/'retryOnFail'.</span></code></pre></div>\n<p>You can think of this as TypeScript “toughening up” the weak guarantees of these types to catch what would otherwise be silent bugs.</p>\n<p>Since this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:</p>\n<ol>\n<li>Declare the properties if they really do exist.</li>\n<li>Add an index signature to the weak type (i.e. <code class=\"language-text\">[propName: string]: {}</code>).</li>\n<li>Use a type assertion (i.e. <code class=\"language-text\">opts as Options</code>).</li>\n</ol>\n<p>{% endraw %}</p>","frontmatter":{"permalink":"/docs/handbook/release-notes/typescript-2-4.html"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/docs/handbook/release-notes/typescript-2-4.html","isOldHandbook":true}}}