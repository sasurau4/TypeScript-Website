{"componentChunkName":"component---src-templates-handbook-tsx","path":"/docs/handbook/declaration-files/templates/module-function-d-ts.html","webpackCompilationHash":"9ba7cceb403e6d704a1e","result":{"data":{"markdownRemark":{"id":"dffe0b58-4b3f-5e59-89a4-1eca716a6c36","excerpt":"{% raw %}`ts\n// Type definitions for ~THE LIBRARY NAME~ ~OPTIONAL VERSION NUMBER~\n// Project: ~THE PROJECT NAME~\n// Definitions by: ~YOUR NAME~ <~A URL FOR YOU…","html":"<p>{% raw %}`<code class=\"language-text\"></code>ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] &#x3C;[~A URL FOR YOU~]></p>\n<p>/*~ This is the module template file for function modules.\n*~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n*~ For example, if you were writing a file for “super-greeter”, this\n*~ file should be ‘super-greeter/index.d.ts’\n*/</p>\n<p>// Note that ES6 modules cannot directly export class objects.\n// This file should be imported using the CommonJS-style:\n//   import x = require(’[~THE MODULE~]’);\n//\n// Alternatively, if —allowSyntheticDefaultImports or\n// —esModuleInterop is turned on, this file can also be\n// imported as a default import:\n//   import x from ’[~THE MODULE~]’;\n//\n// Refer to the TypeScript documentation at\n// <a href=\"https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\">https://www.typescriptlang.org/docs/handbook/modules.html#export—and-import—require</a>\n// to understand common workarounds for this limitation of ES6 modules.</p>\n<p>/*~ If this module is a UMD module that exposes a global variable ‘myFuncLib’ when\n*~ loaded outside a module loader environment, declare that global here.\n*~ Otherwise, delete this declaration.\n*/\nexport as namespace myFuncLib;</p>\n<p>/*~ This declaration specifies that the function\n*~ is the exported object from the file\n*/\nexport = MyFunction;</p>\n<p>/*~ This example shows how to have multiple overloads for your function */\ndeclare function MyFunction(name: string): MyFunction.NamedReturnType;\ndeclare function MyFunction(length: number): MyFunction.LengthReturnType;</p>\n<p>/*~ If you want to expose types from your module as well, you can\n*~ place them in this block. Often you will want to describe the\n*~ shape of the return type of the function; that type should\n*~ be declared in here, as this example shows.\n*~\n*~ Note that if you decide to include this namespace, the module can be\n*~ incorrectly imported as a namespace object, unless\n*~ —esModuleInterop is turned on:\n*~   import * as x from ’[~THE MODULE~]’; // WRONG! DO NOT DO THIS!\n*/\ndeclare namespace MyFunction {\nexport interface LengthReturnType {\nwidth: number;\nheight: number;\n}\nexport interface NamedReturnType {\nfirstName: string;\nlastName: string;\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/*~ If the module also has properties, declare them here. For example,\n *~ this declaration says that this code is legal:\n *~   import f = require(&#39;myFuncLibrary&#39;);\n *~   console.log(f.defaultName);\n */\nexport const defaultName: string;\nexport let defaultLength: number;</code></pre></div>\n<p>}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{% endraw %}</code></pre></div>","frontmatter":{"permalink":"/docs/handbook/declaration-files/templates/module-function-d-ts.html"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/docs/handbook/declaration-files/templates/module-function-d-ts.html","isOldHandbook":true}}}